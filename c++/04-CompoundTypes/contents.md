# 04. Compound types
---
## Index
1. [Array](#Array)
2. [String](#String)
---
<a id="Array"/>

## 1. Array
배열은 **데이터형이 같은 여러 개의 값을 연속적으로 저장할 수 있는 데이터 구조** 이다. 배열에서 각 값은 배열 원소라는 개별 공간에 저장된다. 컴퓨터는 이 모든 원소들을 메모리에 연속적으로 배치한다.  
배열 선언 구문은 다음 세 가지를 선언한다.  
* 각 원소에 저장될 값의 데이터형
* 배열의 이름
* 배열 원소의 개수  

```c++
short months[12];     // 12개의 short형 값을 넣을 수 있는 배열을 생성
```

일반적인 형식 : `typeName arrayName[arraySize]`

---

##### Listing 4.1  
배열을 선언하고, 배열 원소에 값을 대입하며, 배열을 초기화하는 것과 같은 배열에 관련된 몇 가지 사항을 보여준다.  

```c++
// arrayone.cpp -- 정수 형의 작은 배열
#include <iostream>
int main() {
	using namespace std;
	int yams[3];
	yams[0] = 7;
	yams[1] = 8;
	yams[2] = 6;

	int yamcosts[3] = {200, 300, 50};

	cout << "고구마 합계 = ";
	cout << yams[0] + yams[1] + yams[2] << endl;
	cout << yams[1] << "개가 들어 있는 포장은 ";
	cout << "개당 " << yamcosts[1] << "원씩입니다. \n";
	int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];
	total = total + yams[2] * yamcosts[2];
	cout << "세 포장의 총 가격은 " << total << "원입니다.\n";
	cout << "\nyams 배열의 크기는 " << sizeof yams;
	cout << "바이트 입니다.\n";
	cout << "원소 하나의 크기는 " << sizeof yams[0];
	cout << "바이트 입니다.\n";
	return 0;
}
```
##### 출력
```
고구마 합계 = 21
8개가 들어 있는 포장은 개당 300원씩입니다.
세 포장의 총 가격은 4100원입니다.

yams 배열의 크기는 12바이트 입니다.
원소 하나의 크기는 4바이트 입니다.
```
##### 프로그램 분석  
* Listing 4.1은 3개의 원소를 가진 yams라는 배열을 생성한다.
* yams의 각 배열 원소는 int형이므로 int형의 모든 특성을 그대로 가진다.  
* 다음과 같이 배열 원소를 초기화할 수 있다.  
  `int yamcosts[3] = {200, 300, 50};`
* 배열을 초기화하지 않으면, 배열 원소의 값들은 미확정 상태로 남는다.
* 배열 이름에 sizeof 연산자를 적용하면 그 배열의 전체 크기가 바이트 단위로 리턴된다.  

##### 배열 초기화 규칙
C++은 배열을 초기화하는 데 몇 가지 규칙을 적용한다. 이 규칙은 **배열 초기화를 할 수 있는 시기** 를 제한한다. 또한 **배열 원소의 개수와 초기화 리스트에 제시된 값의 개수가 일치하지 않을 때** 어떻게 할 것인지를 결정한다.  
```c++
int card[4] = {3, 6, 8, 10}   //  OK
int hand[4];                  //  OK
hand[4] = {5, 6, 7, 8};       //  NO
hand = cards;                 //  NO
```  
배열을 초기화할 때, 초기화 값의 개수를 배열 원소의 개수보다 모자라게 제공할 수도 있다.
```c++
float hotelTips[5] = {5.0, 2.5};
```
배열을 부분적으로 초기화하면, 컴파일러가 나머지 원소들을 모두 0으로 설정한다.
###### 다른 예시
```c++
long totals[500] = {0};
```
배열을 초기화할 떄 대괄호 속을 비워 두면, 컴파일러가 초기화 값의 개수를 세어 배열의 원소 갯수를 결정한다.
```c++
short things[] = {1, 5, 3, 8};
```
##### C++11 배열 초기화
배열을 초기화할 때, = 부호를 사용하지 않아도 된다.
```c++
double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4};
```
중괄호를 공백으로 하여 모든 배열을 0으로 초기화할 수 있다.
```c++
unsigned int counts[10] = {};
float balances[100] {};
```
리스트 초기화시에 narrowing을 방지할 수 있다.
```c++
long plifs[] = {25, 92, 3.0};   //  NO
char slif[4] = {'h', 'i', 1122011, '\0'}; //  NO
char tlifs[4] {'h', 'i', 112, '\0'};    // OK
```  
---
<a id="String"/>

## 2. String
String이란 **메모리에 바이트 단위로 연속적으로 저장되어 있는 문자** 들을 말한다. 문자들이 메모리에 바이트 단위로 연속적으로 저장된다는 것의 의미는 문자열을 char형의 배열에 저장할 수 있다는 것을 의미한다.  
모든 문자열의 마지막 문자는 반드시 null(\0)문자여야 한다.  
```c++
char dog[8] = {'b', 'e', 'a', 'u', 'x', '', 'i', 'i'};    //  문자열이 아니다.
char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};  //  문자열이다.
```
C++에서 cout은 null 문자를 만날 때까지 문자 단위로 문자열을 처리한다. dog를 cout으로 처리하면 우연히 null 문자를 만날 때까지 이어진다.  
위의 선언이 번거로워 **문자열 상수** 방법으로 초기화한다.
```c++
char bird[10] = "Mr. Cheeps";   //  \0을 저장한다
char fish[] = "Bubbles";        //  컴파일러가 알아서 처리한다.
```  
문자열을 저장할 char형의 배열은 그 크기가 null 문자까지 포함하여 그 문자열에 들어 있는 모든 문자들을 다 넣을 수 있을 만큼 충분히 커야한다. 위의 bird에서 남는 공간은 모두 \0로 채워진다.  
